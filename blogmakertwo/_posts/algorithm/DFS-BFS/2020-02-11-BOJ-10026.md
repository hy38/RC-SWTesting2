---
layout: post
current: post
cover:  assets/images/algorithm/RGB.jpg
navigation: True
title: BOJ 10026 - 적록색약
date: 2020-02-11 16:00:00
tags: [DFS, BFS, algorithm]
class: post-template
subclass: 'post tag-getting-started'
author: hy38
---

> DFS를 이용한 문제해결

# [문제링크](https://www.acmicpc.net/problem/10026)


- 이 문제는 완전탐색 DFS / BFS 문제이다.
- 일반인의 경우와 적록색약의 경우 둘 다 찾아야하므로, DFS를 2번 돌리는 것을 생각하고 시작하자.
- 구역이 몇 개인지 묻는 문제이므로, DFS할 때 카운팅만 잘 해주면 되는 문제이다.
- 여러 방법이 존재하는, 다양한 코딩스타일이 출현할 수 있는 문제인 것 같다.
- 두 번의 DFS를 돌리게 되므로 DFS를 2개를 구현할지, 인자를 추가할지 등의 선택지가 생긴다.
- 알고리즘적으로는 쉬운 문제이지만, 어떤식으로 구현해나갈지가 의외로 큰 비중을 차지하는 문제이다.

# 알고리즘 세우기

1) 입력을 받아 map에 저장한다.

2) 정상인의 경우 몇 개의 RGB 구역이 나오는지를 DFS를 이용하여 구한 뒤, 출력까지 해준다.

3) 적록색약인의 경우 몇몇 개의 RGB 구역이 나오는지를 DFS를 이용하여 구한 뒤, 출력을 해준다.

## 1. 입력을 받아 map에 저장한다.
  
```c++
void input()
{
    scanf("%d", &N);
    for (int i = 0; i < N; ++i) {
        scanf("%s", map[i]);
    }
}
```

- 기존에는 cin, cout을 애용했지만, 간만에 C의 입력을 사용해보았다.

## 1-1. DFS를 진행하기 전에, 내가 선택한 DFS함수에 대해 살펴보겠다.

- 전형적인 DFS함수이지만, 매개변수가 2개 추가되었다.
- c1은 첫번째 색깔, c2는 두번째 색깔을 의미하는데, 이는 DFS 재귀 조건문에 사용된다.
- R과 G를 모두 받아들여 DFS하기 위해, 그리고 하나의 DFS함수를 만들기 위해 이렇게 코드를 짰다.
- 물론, OR 연산이기 때문에 일반인의 경우에도 상관없이 작동한다.
- 다만, 코드에서는 직관성을 위해 일반인의 경우 OR연산을 활용하지는 않았다.

```c++
void DFS(int _row, int _col, char c1, char c2)
{
    if (_row < 0 || _col < 0 || _row >= N || _col >= N)
        return;

    isVisited[_row][_col] = true;

    for (int i = 0; i < 4; ++i) {
        int nxtR = _row + dr[i];
        int nxtC = _col + dc[i];

        if ((map[nxtR][nxtC] == c1 || map[nxtR][nxtC] == c2))
            if (!isVisited[nxtR][nxtC]) {
                DFS(nxtR, nxtC, c1, c2);
            }
    }
}
```

## 2. 정상인의 경우 몇 개의 RGB 구역이 나오는지를 DFS를 이용하여 구한 뒤, 출력까지 해준다.

- 정상인의 경우, 각각의 RGB에 대해 DFS를 이용하였다. RGB를 나타내는 변수 R, G, B를 이용하였으며, 매우 전형적인 완전탐색 DFS 코드이다. DFSAll()이라고 말하기도 하는 것 같다.

> 출력을 하나 찍어주었다. 그리고 R과 G를 0으로 초기화해주었다. B를 초기화하지 않은 이유는, 적록색약인의 경우에도 B는 변하지 않을것이기 때문이다. **R과 G의 구분이 없더라도, B가 몇개의 요소로 이루어져있는지는 변하지 않는다.**

```c++
void go1()
{
    for (int r = 0; r < N; ++r) {
        for (int c = 0; c < N; ++c) {
            if (map[r][c] == 'R' && !isVisited[r][c]) {
                DFS(r, c, 'R', 'R');
                R++;
            } else if (map[r][c] == 'G' && !isVisited[r][c]) {
                DFS(r, c, 'G', 'G');
                G++;
            } else if (map[r][c] == 'B' && !isVisited[r][c]) {
                DFS(r, c, 'B', 'B');
                B++;
            }
        }
    }
    printf("%d ", R + G + B);
    R = G = 0;
}
```

## 3. 적록색약인의 경우 몇몇 개의 RGB 구역이 나오는지를 DFS를 이용하여 구한 뒤, 출력을 해준다.

- go1() 함수와 비슷하게 짜는데, DFS의 인자에 R과 G가 들어간다.
- 또한, DFS를 'map[r][c]가 R이거나 G일 때' 진입하게된다.
- B는 불변이기 때문에 따로 구하지 않아도 된다.

```c++
void go2()
{
    for (int r = 0; r < N; ++r) {
        for (int c = 0; c < N; ++c) {
            if (!isVisited[r][c])
                if ((map[r][c] == 'R' || map[r][c] == 'G')) {
                    DFS(r, c, 'R', 'G');
                    R++;
                }
        }
    }
    printf("%d\n", B + R);
}
```

# 코드 개선을 위한 노력

- 나는 문제해결을 위해 map과 vis배열을 만들어서 결과를 출력했다. 이게 가장 익숙하기도 하고 손에 익기도 했기 때문이다.
- 다른 사람들의 코드를 보고 어떻게 해야 더 최적화된 코드가 될 수 있을지 고민을 해보았다.

## map을 2개 만드는 풀이

- 내 풀이와 다르게 map을 2개 만들어서 map1, map2를 각각 정상인의 경우와 적록색약인의 경우로 나누어서 사용하는 방법이다.
- 이 방법은 얼핏 불필요한 메모리를 사용하게되는것처럼 보일 수 있으나, map을 재사용하지 않아도 되므로 map을 방문했을 때 색칠을 해줌으로써(0 등으로 표시) vis배열의 역할을 수행하는 것이다.
- map2는 G를 R로 치환해준 map이라고 보면 될것같다. 이렇게 되면 결과적으로 2차원배열 2개를 사용하므로, 내가 사용한 방법과 메모리를 똑같게 사용하게된다.

## RGB의 구별을 하지 않는 풀이

```c++
void refactoredGo1(){
    for (int r = 0; r < N; ++r) {
        for (int c = 0; c < N; ++c) {
            if(!isVisited[r][c]){
                char color = map[r][c];
                notDisabled++;
                DFS(r, c, color, color);
            }
        }
    }
    printf("%d ", notDisabled);
}
```

- refactoredGo() 코드를 보면, RGB 각각을 구할필요없이 영역이 몇개인지만 구별하면 되기때문에 저런식으로 변수하나만을 사용할 수 있다.
- 다만, 이렇게 하려면, go2()함수가 go1()함수의 B를 받아쓰고있기 때문에 go2()함수 또한 바꾸어주어야한다.
- **아니면 go2를 바꾸는대신 map2개를 만들면 된다.** 이게 제일 좋은 방법인 것 같다.

## 최적화된 코드 및 노력

- 따라서 최적화된 코드는 map을 2개 만들고, 각각의 영역만 세는 방법인 것 같다. 그렇게 하면 최소 변수 1~2개의 사용을 줄일수있다.

- 또한, 입력에서 G를 R로 바꾸는것도 가능하지만, DFS도중에 G를 'r'로 바꾸는 방법도 있다. 이 때 'R'이 아닌 'r'로 바꾸는 이유는 DFS가 무한루프를 돌 수 있기 때문이다.

## 결론

- ....그냥 편한걸로하자 ㅋㅋ 어차피 코드는 직관적으로 알기 쉬운게 좋은것이니깐 보기편한걸로 짜자.

- [개인적으로 가장 깔끔했던 풀이](https://www.acmicpc.net/source/3290644)

# 알게된 것들

- 코딩스타일이 사람마다 천차만별인것 같다. 그 중에서 효율적으로 코딩하는 습관을 들이자.

# 전체 소스코드

```c++
#include <iostream>
#include <string.h>
using namespace std;
char map[103][103];
bool isVisited[103][103];
int N, R, G, B;
int dr[4] = {1, 0, -1, 0};
int dc[4] = {0, 1, 0, -1};

void input()
{
    scanf("%d", &N);
    for (int i = 0; i < N; ++i) {
        scanf("%s", map[i]);
    }
}

void DFS(int _row, int _col, char c1, char c2)
{
    if (_row < 0 || _col < 0 || _row >= N || _col >= N)
        return;

    isVisited[_row][_col] = true;

    for (int i = 0; i < 4; ++i) {
        int nxtR = _row + dr[i];
        int nxtC = _col + dc[i];

        if ((map[nxtR][nxtC] == c1 || map[nxtR][nxtC] == c2))
            if (!isVisited[nxtR][nxtC]) {
                DFS(nxtR, nxtC, c1, c2);
            }
    }
}

void go1()
{
    for (int r = 0; r < N; ++r) {
        for (int c = 0; c < N; ++c) {
            if (map[r][c] == 'R' && !isVisited[r][c]) {
                DFS(r, c, 'R', 'R');
                R++;
            } else if (map[r][c] == 'G' && !isVisited[r][c]) {
                DFS(r, c, 'G', 'G');
                G++;
            } else if (map[r][c] == 'B' && !isVisited[r][c]) {
                DFS(r, c, 'B', 'B');
                B++;
            }
        }
    }
    printf("%d ", R + G + B);
    R = G = 0;
}

void go2()
{
    for (int r = 0; r < N; ++r) {
        for (int c = 0; c < N; ++c) {
            if (!isVisited[r][c])
                if ((map[r][c] == 'R' || map[r][c] == 'G')) {
                    DFS(r, c, 'R', 'G');
                    R++;
                }
        }
    }
    printf("%d\n", B + R);
}

int main()
{
    input();
    go1();
    memset(isVisited, false, sizeof(isVisited));
    go2();
    return 0;
}
```