---
layout: post
current: post
cover:  assets/images/algorithm/flood.jpg
navigation: True
title: BOJ 2468 - 안전 영역
date: 2020-02-07 16:00:00
tags: [DFS, BFS, simulation, algorithm]
class: post-template
subclass: 'post tag-getting-started'
author: hy38
---

> DFS를 이용한 문제해결

# [문제링크](https://www.acmicpc.net/problem/2468)


- 이 문제는 완전탐색 시뮬레이션 DFS / BFS 문제이다.
- 아무 지역도 물에 잠기지 않을 수 있다는 단서가 있으므로, 답을 1부터 설정한다.
- 시행착오가 있었다. 불필요한 작업들을 많이 짜는 알고리즘을 선택했었다.

# 알고리즘 세우기

1) 입력받으면서 지역들의 최대 높이를 찾는다.

2) 1부터 최대 높이까지 시뮬을 돌린다. 이 때 변수를 i라 하자.

2-1) i보다 높이가 낮거나 같은 지역들을 모두 0으로 색칠한다.

2-2) DFS를 이용하여 완전탐색하면서 0보다 큰 지역들의 개수를 센다.

2-3) 최대가 되는 답을 구해준다. 이 때, 문제에서 주어진대로 처음의 답은 1로 설정해둔다.

3) 물에 잠기지 않는 안전한 영역의 최대 개수를 출력한다.

## 삽질한 포인트

- 2-1)에서 색칠을 하는데 불필요하게 DFS를 사용하였다. 왜그랬을까 ㅜㅜ..

- 2-1)에서 색칠 후 DFS를 사용하였으므로 방문배열을 초기화해주었다...

- 2-3)에서 2-1)로 반복할 때 map을 초기화해주었다. 초기화하지 않아도 물의 높이가 점점 올라가는 식으로 반복문이 작동하기 때문에 코드로 정상적으로 돌아간다.

## 1. 입력받으면서 지역들의 최대 높이를 찾는다.
  
```C++
void input()
{
    cin.sync_with_stdio(false);
    cin.tie(NULL);
    cin >> N;
    for (int r = 0; r < N; ++r) {
        for (int c = 0; c < N; ++c) {
            cin >> map[r][c];
            if (map[r][c] > maxHeight)
                maxHeight = map[r][c];
        }
    }
}
```

- map을 입력받으면서, maxHeight라는 변수를 이용하여 최대 높이를 구한다.

## 2. 1부터 최대 높이까지 시뮬을 돌린다. 이 때 변수를 i라 하자.

- 문제에서 주어진대로 답을 반환할 변수 ret을 1로 설정한다.

```C++
    int ret = 1;
    for (int i = 1; i <= maxHeight; ++i) {
        ...
        some code
        ...
    }
```

## 2-1. i보다 높이가 낮거나 같은 지역들을 모두 0으로 색칠한다.

- i이하의 지역을 0으로 칠해준다.

```C++
    //  물에 잠기게 하기.
    for (int r = 0; r < N; ++r) {
        for (int c = 0; c < N; ++c) {
            if (map[r][c] <= i)
                map[r][c] = 0;
        }
    }
```

## 2-2. DFS를 이용하여 완전탐색하면서 0보다 큰 지역들의 개수를 센다.

- [연결 요소의 개수](https://www.acmicpc.net/problem/11724) 문제와 유사하게 진행하면 된다.

```C++
    int cnt = 0;
    for (int r = 0; r < N; ++r) {
        for (int c = 0; c < N; ++c)
            if (!isVisited[r][c])
                if (map[r][c] > 0) {
                    ++cnt;
                    DFS(r, c);
                }
    }
```

## 2-3. 최대가 되는 답을 구해준다.

```c++
    int ret = 1;
    for (int i = 1; i <= maxHeight; ++i) {
        ...
        some code
        ...

        ret = max(ret, cnt);
        memset(isVisited, false, sizeof(isVisited));
    }
    return ret;
```

## 3. 물에 잠기지 않는 안전한 영역의 최대 개수를 출력한다.

- 함수가 정답을 반환하도록 만들어 리턴 시 정답을 출력하도록 하였다.

```C++
int main()
{
    input();
    cout << solve() << "\n";
    return 0;
}
```

# 알게된 것들

- 어떤 코드를 짜더라도 조금만 생각을 더 하면 실수를 줄일 수 있다.
- 삽질한 코드에 비해 메모리는 23%가량 적게 사용하였으며, 시간은 28%가량 줄었다.
- 실수를 줄이고, 최소의 시간, 최소의 메모리를 사용하도록 코드를 짜보자.

# 전체 소스코드

```c++
#include <algorithm>
#include <iostream>
#include <string.h>
using namespace std;

int map[103][103], isVisited[103][103];
int N, maxHeight;
int dr[4] = {1, 0, -1, 0};
int dc[4] = {0, 1, 0, -1};

void DFS(int row, int col)
{
    isVisited[row][col] = true;

    for (int i = 0; i < 4; ++i) {
        int nr = row + dr[i];
        int nc = col + dc[i];

        if (0 <= nr && nr < N && 0 <= nc && nc < N) {
            if (!isVisited[nr][nc] && map[nr][nc] > 0)
                DFS(nr, nc);
        }
    }
}

int solve()
{
    int ret = 1;
    for (int i = 1; i <= maxHeight; ++i) {

        //  물에 잠기게 하기.
        for (int r = 0; r < N; ++r) {
            for (int c = 0; c < N; ++c) {
                if (map[r][c] <= i)
                    map[r][c] = 0;
            }
        }

        int cnt = 0;
        for (int r = 0; r < N; ++r) {
            for (int c = 0; c < N; ++c)
                if (!isVisited[r][c])
                    if (map[r][c] > 0) {
                        ++cnt;
                        DFS(r, c);
                    }
        }

        ret = max(ret, cnt);
        memset(isVisited, false, sizeof(isVisited));
    }
    return ret;
}

void input()
{
    cin.sync_with_stdio(false);
    cin.tie(NULL);
    cin >> N;
    for (int r = 0; r < N; ++r) {
        for (int c = 0; c < N; ++c) {
            cin >> map[r][c];
            if (map[r][c] > maxHeight)
                maxHeight = map[r][c];
        }
    }
}

int main()
{
    input();
    cout << solve() << "\n";
    return 0;
}
```