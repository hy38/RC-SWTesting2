---
layout: post
current: post
cover:  assets/images/algorithm/area.jpg
navigation: True
title: BOJ 2583 - 영역 구하기
date: 2020-02-07 10:00:00
tags: [DFS, BFS, algorithm]
class: post-template
subclass: 'post tag-getting-started'
author: hy38
---

> DFS를 이용한 문제해결

# [문제링크](https://www.acmicpc.net/problem/2583)


- 이 문제는 완전탐색 DFS / BFS 문제이다.
- 모든 모눈종이들의 영역을 1로 표시한 후, 나머지 0으로 표시된 영역들을 탐색해나가면 된다.
- 특별한 점은, 영역의 크기를 구할 때 어떤식으로 카운팅을 할지가 관건인 것 같다.
- 비슷한 문제로 [단지번호붙이기](https://www.acmicpc.net/problem/2667), [연결 요소의 개수](https://www.acmicpc.net/problem/11724) 등이 있다.

# 알고리즘 세우기

1) 입력받으면서 모눈종이들의 영역을 1로 칠해준다.

2) 0인 영역들을 탐색하면서 몇 개의 연결 요소로 이루어져있는지 파악한다.

3) 각 연결 요소마다 영역의 크기를 구한다.

4) 3에서의 영역의 크기들을 정렬 한 후 출력기준에 알맞게 정답을 출력한다.


## 1. 입력받으면서 모눈종이들의 영역을 1로 칠해준다.
  
```c++
void input(){
    cin >> row >> col >> squares;

    for (int i = 0; i < squares; ++i) {
        int r1, c1, r2, c2;
        cin >> c1 >> r1 >> c2 >> r2;

        for (int r = r1; r < r2; ++r) {
            for (int c = c1; c < c2; ++c) {
                map[r][c] = 1;
            }
        }
    }
}
```

- 모눈종이의 영역을 입력받아 그 영역들을 1로 칠해준다.

## 2. 0인 영역들을 탐색하면서 몇 개의 연결 요소로 이루어져있는지 파악한다.

- DFS를 이용해서 연결요소의 개수를 파악한다. 이 때 모든 좌표에 대해 DFS를 진행한다.
- DFS를 main에서 몇 번 step하는지를 cnt 변수를 이용하여 카운팅하였다.

```C++
    for (int r = 0; r < row; ++r) {
        for (int c = 0; c < col; ++c) {
            if (map[r][c] == 0) {
                param = 0;
                DFS(r, c);
                ans.push_back(param);
                ++cnt;
            }
        }
    }
```

- DFS 진입조건에 방문했는지의 여부를 isVisited[r][c] 배열로 처리하지 않은 이유는 DFS함수 내부에서 map[r][c]을 2로 칠할것이기 때문이다. 이렇게 함으로써 불필요한 row * col 만큼의 메모리를 줄일 수 있다.

```c++
void DFS(int _row, int _col){

    if (_row < 0 || _col < 0 || _row >= row || _col >= col)
        return;

    ++param;
    map[_row][_col] = 2;

    for (int i = 0; i < 4; ++i) {
        int nextRow = _row + dr[i];
        int nextCol = _col + dc[i];

        if (map[nextRow][nextCol] == 0) {   //  DFS재귀 진입 조건
            DFS(nextRow, nextCol);
        }
    }
}
```

## 3. 각 연결 요소마다 영역의 크기를 구한다.

- 사실 여러 방법이 존재할 수 있다. DFS함수의 반환형을 int로 바꾸어 활용하는 방법도 존재한다.
- 나는 param이라는 변수를 설정하여 영역의 크기를 구했다. 이 변수는 각 연결 요소마다 다르므로 제 때 초기화를 해주어야 한다.
- param 변수를 vector에 보관하였다.

## 4. 3에서의 영역의 크기들을 정렬 한 후 출력기준에 알맞게 정답을 출력한다.

- 연결 요소의 개수를 먼저 출력하였다.
- 그 후, 3에서 vector에 보관한 param들을 정렬하여 출력하였다., 

```C++
    cout << cnt << "\n";
    sort(ans.begin(), ans.end());
    for (int i = 0; i < ans.size(); ++i)
        cout << ans[i] << " ";

    return 0;
```

# 알게된 것들
- 워낙 간단한 문제라(정확히는 여러개의 기초문제가 혼합된 문제인 것 같다.) 크게 신경쓸일이 많지 않았다.
- 입력을 처리할 때 문제에서 주어진 좌표인 (x, y)와 내가 주로 사용하는 좌표계인 (r, c)가 달라서 문제처럼 입력을 받아야할지에 대해 고민을 했었다.
- 그러나 어차피 그래프가 상하 혹은 좌우 대칭이더라도 문제의 본질인 연결 요소의 개수와 각 요소별 크기 구하는것은 똑같기에 내가 편한 방식으로 문제를 해결하였다.
- 따라서 map의 입출력이 문제에서 주어진 것과 사뭇 다를 수 있다.

# 전체 소스코드

```c++
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

int row, col, squares, cnt, param;
int map[103][103];
int dr[4] = {0, 1, 0, -1};
int dc[4] = {1, 0, -1, 0};
vector<int> ans;

void input()
{
    cin >> row >> col >> squares;

    for (int i = 0; i < squares; ++i) {
        int r1, c1, r2, c2;
        cin >> c1 >> r1 >> c2 >> r2;

        for (int r = r1; r < r2; ++r) {
            for (int c = c1; c < c2; ++c) {
                map[r][c] = 1;
            }
        }
    }
}

void DFS(int _row, int _col)
{

    if (_row < 0 || _col < 0 || _row >= row || _col >= col)
        return;

    ++param;
    map[_row][_col] = 2;

    for (int i = 0; i < 4; ++i) {
        int nextRow = _row + dr[i];
        int nextCol = _col + dc[i];

        if (map[nextRow][nextCol] == 0) {
            DFS(nextRow, nextCol);
        }
    }
}

int main()
{
    cin.sync_with_stdio(false);
    cin.tie(NULL);
    input();

    for (int r = 0; r < row; ++r) {
        for (int c = 0; c < col; ++c) {
            if (map[r][c] == 0) {
                param = 0;
                DFS(r, c);
                ans.push_back(param);
                ++cnt;
            }
        }
    }

    cout << cnt << "\n";
    sort(ans.begin(), ans.end());
    for (int i = 0; i < ans.size(); ++i)
        cout << ans[i] << " ";

    return 0;
}
```