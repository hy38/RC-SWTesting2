---
layout: post
current: post
cover:  assets/images/algorithm/bacon.jpg
navigation: True
title: BOJ 1389 - 케빈 베이컨의 6단계 법칙
date: 2020-02-12 14:00:00
tags: [DFS, BFS, floyd-warshall, simulation, algorithm]
class: post-template
subclass: 'post tag-getting-started'
author: hy38
---

> DFS를 이용한 문제해결

# [문제링크](https://www.acmicpc.net/problem/1389)


- 이 문제는 플로이드-워셜 알고리즘으로 해결 가능한 문제이다.
- 다만, 아직 플로이드-워셜에 대해 깊게 공부하지 않아 DFS로 반복 탐색해가며 문제를 해결하였다.
- 인접리스트를 입력받아 사용하였다.

- 문제가 길어서 이해하는데 시간이 걸렸지만, 결국 그래프에서 u에서 v로 가는 최단경로를 구하는 것을 케빈 베이컨 게임이라 하고,
- u에서 모든 정점 v에 대해 케빈 베이컨 게임을 하여 각각의 합을 구한 것이 케빈 베이컨 수 라고 한다.
- 따라서, 모든 정점별 케빈 베이컨 수 중에 최소가 되는 정점을 출력하면 된다.

# 알고리즘 세우기

1) 입력을 인접리스트 형식으로 입력받는다.

2) 정점의 개수 N만큼 각 정점에서 다른 정점들로 가는 최소 경로들을 구한다.

2-1) DFS를 이용하여 여러 경로들 중에 최소 경로를 구한다.

3) 가장 작은 케빈 베이컨 수를 갖는 사람의 번호(인덱스)를 구한다.

4) 3에서의 번호를 출력한다.

## 1. 입력을 인접리스트 형식으로 입력받는다.

- 벡터들의 사이즈를 N+1 로 설정해준 뒤, 입력을 받는다.

```C++
void input()
{
    cin.sync_with_stdio(false);
    cin.tie(NULL);
    cin >> N >> edges;
    adj.resize(N + 1);
    vis.resize(N + 1);
    for (int i = 0; i < edges; ++i) {
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
}
```

## 2. 정점의 개수 N만큼 각 정점에서 다른 정점들로 가는 최소 경로들을 구한다.

- 1번 정점부터 다른 정점까지의 최소 경로의 합인 '케빈 베이컨 수'를 구한다.
- tmp라는 큰 변수를 설정하여 i -> j로 가는 최소 경로를 저장한다.
- 최소 경로 tmp를 sum에 저장한다.

```c++
    for (int i = 1; i <= N; ++i) {
        sum = 0;

        //  각각의 인접리스트에 대해 최소경로를 구해 sum에 더해준다.
        for (int j = 1; j <= N; ++j) {
            if (i != j) {
                tmp = 987654321;
                DFS(i, j, 0);
                sum += tmp;
            }
        }

        ... some code ...

    }
```

## 2-1. DFS를 이용하여 여러 경로들 중에 최소 경로를 구한다.

- 최소경로는 DFS를 이용하여 구하며, 다음과 같이 구할 수 있다.

```c++
void DFS(int node, int target, int c)
{
    if (node == target) {
        //  find the SHORTEST path among paths.
        tmp = min(tmp, c);
        return;
    }

    for (int i = 0; i < adj[node].size(); ++i) {
        int next = adj[node][i];

        if (!vis[next]) {
            vis[node] = true;
            DFS(next, target, c + 1);
            vis[node] = false;
        }
    }
}
```

- 주목할 점은, DFS가 인접리스트를 순회하며 모든 정점을 찾아가는데, target 정점을 찾았을 때 **최소**인 경로만을 tmp에 저장한다는 것이다.

> 다음 코드가 이 문제의 해심이라고 생각한다.

```c++
    if (node == target) {
        //  find the SHORTEST path among paths.
        tmp = min(tmp, c);
        return;
    }
```

## 3. 가장 작은 케빈 베이컨 수를 갖는 사람의 번호(인덱스)를 구한다.

- 변수 sum은 i정점에서의 '케빈 베이컨 수' 를 의미한다. 이 sum이 최소인지를 결정해야한다.

- i의 케빈 베이컨 수가 가장 작은지를 판단한 후에, 가장 작을 경우에 해당 인덱스를 ans변수에 저장한다.

> 이 때, 가장 작은지를 판단함에 있어서 등호를 붙이게 되면, 전체 큰 for문이 증가하는 방식이기 때문에, 자연스럽게 같은 수에 대해서는 큰 인덱스가 저장된다. 따라서 등호를 붙이지 않아야한다.

```c++
for (int i = 1; i <= N; ++i) {
        sum = 0;

        ... some code ...

        //  가장 작은 케빈 베이컨 수를 갖는 사람의 인덱스를 구한다.
        if (sum < big_N) { //  WRONG IF sum <= big_N
            big_N = sum;
            ans = i;
        }
    }
```

## 4. 번호를 출력한다.

```C++
    cout << ans << "\n";
    return 0;
```

# 알게된 것들

- DFS 함수 내에서 DFS함수의 매개변수와 전역변수를 비교하여 minimum을 정하는 것은 처음 해보았다.
- 경로가 여러가지가 나올 수가 있는데, 최소경로를 찾는 방법을 고민할 수 있었다.
- 어느정도는 DFS와 재귀에 익숙해진것같다. 물론 첫걸음을 뗀 느낌이다.

# 전체 소스코드

```c++
#include <algorithm>
#include <iostream>
#include <vector>
using namespace std;

vector<vector<int>> adj;
vector<bool> vis;
int N, edges, u, v, ans, sum, tmp, big_N = 987654321;

/*
vis배열을 임의로 초기화하지 않아도됨. DFS함수 내에서 진행하므로..
문제에서 숫자가 작은 사람의 인덱스를 구하라했으니 등호는 마지막에 빼야함.

완전탐색을 하는데, 각 경로들 중에서도 최소경로를 구해야함.
최소경로라는게 중요함.
*/

void DFS(int node, int target, int c)
{
    if (node == target) {
        //  find the SHORTEST path among paths.
        tmp = min(tmp, c);
        return;
    }

    for (int i = 0; i < adj[node].size(); ++i) {
        int next = adj[node][i];

        if (!vis[next]) {
            vis[node] = true;
            DFS(next, target, c + 1);
            vis[node] = false;
        }
    }
}

void input()
{
    cin.sync_with_stdio(false);
    cin.tie(NULL);
    cin >> N >> edges;
    adj.resize(N + 1);
    vis.resize(N + 1);
    for (int i = 0; i < edges; ++i) {
        cin >> u >> v;
        adj[u].push_back(v);
        adj[v].push_back(u);
    }
}

int main()
{
    input();

    for (int i = 1; i <= N; ++i) {
        sum = 0;

        //  각각의 인접리스트에 대해 최소경로를 구해 sum에 더해준다.
        for (int j = 1; j <= N; ++j) {
            if (i != j) {
                tmp = 987654321;
                DFS(i, j, 0);
                sum += tmp;
            }
        }

        //  가장 작은 케빈 베이컨 수를 갖는 사람의 인덱스를 구한다.
        if (sum < big_N) { //  WRONG IF sum <= big_N
            big_N = sum;
            ans = i;
        }
    }

    cout << ans << "\n";
    return 0;
}
```