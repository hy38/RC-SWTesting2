---
layout: post
current: post
cover:  assets/images/algorithm/lab.jpg
navigation: True
title: BOJ 14502 - 연구소
date: 2020-02-01 10:00:00
tags: [DFS, BFS, algorithm]
class: post-template
subclass: 'post tag-getting-started'
author: hy38
---

> BFS를 이용한 문제해결

# [문제링크](https://www.acmicpc.net/problem/14502)


- 이 문제는 단순한 완전탐색 시뮬레이션 DFS / BFS 문제이다.
모든 경우에 대해 벽을 세우고, 각각의 지도에 대해 바이러스 표시된 곳을
상하좌우로 BFS 혹은 DFS 돌리면 된다.
- 이 문제의 복병은 다름아닌 벽을 세우는 것이라고 생각한다. 벽 3개를 어떻게 세울지가
가장 큰 고민이 되는 문제가 아닐까 싶다.


# 알고리즘 세우기

1) 입력받으면서 바이러스의 좌표를 저장한다.

2) 모든 가능한 경우의 벽들을 세운다.

3) 모든 가능한 경우마다 BFS(혹은 DFS)를 이용하여 바이러스를 퍼뜨린다.

3-1) 각 경우마다 안전 영역의 크기를 구한 후, 최대 영역인지 판단하여 update한다.

3-2) 다시 바이러스를 퍼뜨려야하므로, 지도와 방문배열을 초기화한다.

4) 정답을 출력한다.


## 1. 입력받으면서 바이러스의 좌표를 저장한다.
  
  ```C++
    cin.sync_with_stdio(false);
    cin.tie(NULL);

    //  INPUT
    cin >> row >> col;
    for (int r = 0; r < row; ++r){
        for (int c = 0; c < col; ++c) {
            cin >> map[r][c];
            mapClone[r][c] = map[r][c];
            if (map[r][c] == 2)
                q.push(make_pair(r, c));
        }
    }
  ```
- 바이러스의 좌표를 저장하는 queue를 만들어 넣어준다.

## 2. 모든 가능한 경우의 벽들을 세운다.

- 사실 이 문제에서 가장 애먹었던 부분이자 난감한 사항이었다.
다양한 방법이 있는데, 우선 나는 이렇게 했다.
```C++
    for (int i = 0; i < row * col; i++)
        for (int j = 0; j < row * col; j++)
            for (int k = 0; k < row * col; k++) {
                solve(i / col, i % col, j / col, j % col, k / col, k % col);
            }
```
3중 for문을 만들어 /와 %연산을 이용하여 모든 경우의 좌표들에 벽을 세웠다.
이 때, solve()함수 안에서 중복되는 좌표와 벽을 세우는 조건들을 추가하였다.

이 방법 외에도 다음과 같은 방법이 있다. 개인적으로 **정말** 깔끔한 코드라고 생각한다.
```c++
int explore()
{
    int ans = 0;
    int n_nodes = node[0].size();
    for (int i = 0; i < n_nodes; ++i) {
        lab[node[0][i]][node[1][i]] = 1;
        for (int j = i + 1; j < n_nodes; ++j) {
            lab[node[0][j]][node[1][j]] = 1;
            for (int k = j + 1; k < n_nodes; ++k) {
                lab[node[0][k]][node[1][k]] = 1;
                ans = max(ans, simulate());
                lab[node[0][k]][node[1][k]] = 0;
            }
            lab[node[0][j]][node[1][j]] = 0;
        }
        lab[node[0][i]][node[1][i]] = 0;
    }
    return ans;
}
// 출처 : https://www.acmicpc.net/source/6417565
```
이 분의 코드는 node배열에 빈 공간인 '0'들의 좌표를 저장한다.
그러면서 각각의 좌표들에 대해 완전탐색을 하는데, 다시 원상태로 복구해주는 코드까지 들어가있다.
정말 부럽다.

## 3. 모든 가능한 경우마다 BFS(혹은 DFS)를 이용하여 바이러스를 퍼뜨린다.

나는 BFS를 이용하였지만, DFS를 이용해도 상관없어보인다.
어차피 목적은 바이러스를 퍼뜨리는것이니깐.
```c++
void BFS()
{
    while (!qClone.empty()) {
        pair<int, int> front;
        front = qClone.front();
        isVisited[front.first][front.second] = true;
        mapClone[front.first][front.second] = 2;  //  바이러스가 퍼졌음을 표시해준다.
        qClone.pop();

        for (int i = 0; i < 4; ++i) { //  상하좌우 BFS
            int nextRow = front.first + dr[i];
            int nextCol = front.second + dc[i];

            //  check index error
            if (nextRow < 0 || nextCol < 0 || nextRow >= row || nextCol >= col)
                continue;

            if (!isVisited[nextRow][nextCol] && mapClone[nextRow][nextCol] == 0) {
                isVisited[nextRow][nextCol] = true; //  방문표시
                qClone.push({nextRow, nextCol});
            }
        }
    }
}
```
qClone이라는 큐를 사용하였으며, 이는 큐를 초기바이러스가 들어있는 처음상태로 복구해주어야하기 때문이다.
비슷한 이유로 mapClone이라는 2차원 배열을 사용하였다.
DFS를 사용했으면 임시 큐에 사용되는 불필요한 메모리와 임시 큐를 초기화하는 비용을 줄였을것 같다.
전형적인 BFS를 구현하였다.

### 3-1. 각 경우마다 안전 영역의 크기를 구한 후, 최대 영역인지 판단하여 update한다.
```C++
area = max(area, checkArea());
```
### 3-2. 다시 바이러스를 퍼뜨려야하므로, 지도와 방문배열을 초기화한다.
```C++
restoreMap();
for (int r = 0; r < row; ++r) {
    memset(isVisited[r], false, sizeof(bool) * col);
}
```
추후에 알게되었는데, isVisited배열은 반복문을 이용한 2차원배열의 초기화 이외에도
다음과 같이 초기화 할 수 있다.
```C++
memset(isVisited, false, sizeof(isVisited);
```
물론 memset()을 사용하기 위해 <string.h> 헤더를 포함해야한다.

## 4. 정답을 출력한다.
가장 큰 값으로 update되어있는 변수 area를 출력한다.
```C++
cout << area << "\n";
```

# 알게된 것들
- C++ STL의 queue에서 = 연산자로 queue를 복사할 수 있다.
예 : q1 = q2 // q2의 원소들을 q1에 덮어씌움

- 벽을 세우는데 다양한 방법이 존재하지만, 깔끔하게 짜려는 습관을 들이자.
- 좋은 코드를 많이 보고 배우자.

# 전체 소스코드
```c++
#include <algorithm>
#include <iostream>
#include <queue>
#include <string.h>
#include <vector>
using namespace std;

int map[9][9], mapClone[9][9], row, col, area;
bool isVisited[9][9], flag;
int dr[4] = {0, 1, 0, -1};
int dc[4] = {1, 0, -1, 0};
queue<pair<int, int>> q, qClone;
/*
    1. 입력
    2. 완전탐색 이용하여 벽을 설치
    3. 각각의 케이스마다 BFS 진행 후 안전 area를 검사
        4. area의 최대를 구함
        5. isVisited를 초기화
    6. 최대 area 출력
*/

void BFS()
{
    while (!qClone.empty()) {
        pair<int, int> front;
        front = qClone.front();
        isVisited[front.first][front.second] = true;
        mapClone[front.first][front.second] = 2;
        qClone.pop();

        for (int i = 0; i < 4; ++i) {
            int nextRow = front.first + dr[i];
            int nextCol = front.second + dc[i];

            //  check index error
            if (nextRow < 0 || nextCol < 0 || nextRow >= row || nextCol >= col)
                continue;

            if (!isVisited[nextRow][nextCol] && mapClone[nextRow][nextCol] == 0) {
                isVisited[nextRow][nextCol] = true;
                qClone.push({nextRow, nextCol});
            }
        }
    }
}

int checkArea()
{
    int ret = 0;
    for (int r = 0; r < row; ++r)
        for (int c = 0; c < col; ++c)
            if (mapClone[r][c] == 0)
                ret++;

    return ret;
}

void restoreMap()
{
    for (int r = 0; r < row; ++r)
        for (int c = 0; c < col; ++c)
            mapClone[r][c] = map[r][c];
}

void solve(int r1, int c1, int r2, int c2, int r3, int c3)
{
    //  중복 좌표 검증의 필요성? 벽이 많을수록 공간도 많음이 보장되는가?
    //  필요해보임.. 반례도 있지만 문제조건에도 명시되어있음.
    if ((r1 == r2 && c1 == c2) || (r2 == r3 && c2 == c3) || (r3 == r1 && c3 == c1))
        return;

    //  벽을 설치할 공간이 이미 벽이거나 바이러스인 경우를 차단.
    if (mapClone[r1][c1] != 0 || mapClone[r2][c2] != 0 || mapClone[r3][c3] != 0)
        return;

    //  벽 설치
    mapClone[r1][c1] = mapClone[r2][c2] = mapClone[r3][c3] = 1;
    
    qClone = q; //  초기 입력할때의 2들을 넣어주어야함.
    
    BFS();
    
    area = max(area, checkArea());  //  변수 area를 최대로 update
    
    restoreMap();
    for (int r = 0; r < row; ++r) { //  isVisited 초기화
        memset(isVisited[r], false, sizeof(bool) * col);
    }
}

int main()
{
    cin.sync_with_stdio(false);
    cin.tie(NULL);

    //  INPUT
    cin >> row >> col;
    for (int r = 0; r < row; ++r)
        for (int c = 0; c < col; ++c) {
            cin >> map[r][c];
            mapClone[r][c] = map[r][c];
            if (map[r][c] == 2)
                q.push(make_pair(r, c));
        }

    //  완전탐색을 이용하여 벽을 설치
    for (int i = 0; i < row * col; i++)
        for (int j = 0; j < row * col; j++)
            for (int k = 0; k < row * col; k++) {
                solve(i / col, i % col, j / col, j % col, k / col, k % col);
            }

    cout << area << "\n";

    return 0;
}
```
